Задание 2. Singleton
Класс ParserPageService реализован как Singleton, поскольку компоненты в Spring, помеченные аннотациями @service, @component, @repository, @controller по умолчанию создаются с областью видимости (scope) синглтона.
Это значит, что Spring создает единственный экземпляр такого класса и использует его в течение всего жизненного цикла приложения.
На классе ParserPageService висит аннотация @service, следовательно этот класс Singleton.


Задание 3. Prototype
Интерфейс Sheep и класс BlackSheep реализуют паттерн Prototype, потому что в их основе лежит способность клонировать объекты, создавая новые экземпляры с теми же данными, что и у исходного объекта. 
Интерфейс Sheep содержит метод clone(), который возвращает новый объект того же типа. Это ключевой элемент паттерна Prototype, так как он предполагает, что каждый класс, реализующий этот интерфейс, должен поддерживать клонирование самого себя. 
Класс BlackSheep реализует интерфейс Sheep, предоставляя собственную реализацию метода clone(). Этот метод создает и возвращает новый объект BlackSheep, копируя состояние текущего объекта.
При вызове метода clone() создается новая овца с тем же именем, что и у исходного объекта, что соответствует принципу клонирования в Prototype, где каждый объект может "создавать" копии самого себя.


Задание 4. Static Fabric Method
Класс Player представляет собой пример паттерна Static Factory Method по следующим причинам:
В классе Player есть приватный конструктор, следоватльно, прямое создание объектов через new Player() запрещено, что заставляет использовать статические методы для создания экземпляров класса, контролируя процесс их создания.
Также присутсвуют статические методы getCricketPlayer(), getFootballPlayer(), которые инкапсулируют логику создания объектов. Они возвращают готовые объекты Player с предопределёнными значениями.


Задание 5. Builder
Класс Car представляет собой пример паттерна Builder по следующим причинам:
Класс Car содержит обязательные параметры (двигатель и количество колёс) и необязательные параметры (цвет, наличие GPS и кондиционера).
Внутренний статический класс Builder отвечает за создание объекта Car, в нём задаются обязательные параметры через конструктор и опциональные через методы. 
Также есть метод build(), который возвращает готовый объект класса Car. 


Задание 6. Factory Method
В пакете Factory Method находятся классы, которые представляют собой паттерн Factory Method.
Интерфейс Animal(Продукт) определяет метод speak(), который должен реализовать каждый конкретный тип животного.
Класс Dog это конкретный продукт интерфейса Animal, который реализуют поведение метода speak().
Абстрактный класс AnimalFactory содержит абстрактный метод createAnimal(), который будет реализован в конкретных фабриках, метод createAnimal и явлется фабричным методом.
Класс DogFactory конкретный создатель, который реализуют метод createAnimal() для создания определённых видов животных.


Задание 7. Abstract Factory
В пакете AbstractFactory находятся классы, которые представляют собой паттерн Abstract Factory.
Интерфейс CarFactory определяет метод для создания абстрактного продукта Engine.
Интерфейс Engine представляет абстрактный продукт.
Конкретная Фабрика ElectricCarFactory реализует создание конкретного продукта ElectricEngine.
Конкретный продукт ElectricEngine реализует абстрактный продукт Engine.


Задание 8. Adapter
Интерфейс USBTypeC определяет метод chargeWithUSBC() предназначенный для работы с устройствами, использующими USB-C.
Адаптируемый класс класс LightningDevice имеет метод chargeWithLightning(), несовместимый с целевым интерфейсом.
Класс LightningToUSBCAdapter является адаптером, он реализует интерфейс USBTypeC, переводя вызовы chargeWithUSBC() в вызовы chargeWithLightning().
Класс LightningToUSBCAdapter наследуется от интерфейса USBTypeC, а также содержит в своем поле класс LightningDevice, который передается в конструктор.
Таким образом в классе LightningToUSBCAdapter композируется класс LightningDevice.


Задание 9. Bridge
В пакете Bridge находятся классы которые представляют собой паттерн Bridge.
Интерфейс Device ялвяется реализацией, содержит различные методы.
Класс RemoteControl представляет собой абстракцию, которая использует интерфейс Device для взаимодействия с конкретной реализацией (содержит интерфейс Device в поле).
Интерфейс Device(реализация) реализуется классами TV(конкретная реализация) и Radio(конкретная реализация), которые являются наследниками интерфейса Device.
Класс AdvancedRemoteControl представялет собой уточненную абстракцию. Таким образом, между классами RemoteControl и Device находится мост, который позволяет в классе RemoteControl использовать методы интерфейса Device.


Задание 10. Composite
В пакете Composite находятся классы, которые представляют собой паттерн Composite.
Интерфейс Graphic является компонентом, содержит метод draw().
Классы Circle и Square являются листами, реализуют интерфейс Graphic и представляют отдельные графические элементы. 
Класс CompositeGraphic является узлом реализует интерфейс Graphic и содержит список других графических объектов. Он позволяет добавлять и удалять объекты, а также реализует метод draw, который вызывает метод draw для каждого из своих дочерних объектов.









